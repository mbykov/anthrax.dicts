#

* === ОБЩАЯ СХЕМА ===
 - get indecl / irreg - из всех словарей - cdict.trns
   - создаю общий cdict.trn - {dname}
   - indecl / либо irreg, т.е. morphs
 - stem by nest
   - получаю chain для verb / name / adverb
 - get все словари by dict
   - создаю cdict.trn




* nest - verbs
 -  ύω: δύω, δυ δύσω ; θύω θυ θύσω ; λύω λυ λύσω ; βουλεύω βουλευ βουλεύσω βουλεύσομαι =>

* stem / astem
 - makeDict - astem, включая префикс ; prefix = {pref,...}, marphas
 - uniq, makeNest - вычисляет stem, и тот же prefix, и cstype
 - wkt.js - nest - словарь стемов и vars / cstype
 - словари dict.js - rdict, dict, trns, cstype для коллекции
 - антракс - schemes и morphs

* DIAREW - BUG
 - makeWkt διαιρέω - где префикс ????


* DVR - нужен второй словарь, и пусть DVR - makeDvr.sj
 - testRow - нормально
 - prefix
 - если compound-suffix - убрать
 -

* nest - главный словарь
 - запрос к nest - по стему
 - затем запрос ко всем dbs по cdict.dict за trns
 - если есть WKT - добавить vars
 - иначе только cstype

* nest - существительные - прилагательные
 - при созданиии словаря, если есть оба, выбирать adject
 - при выборе _probe - выбрать adject
 - тогда сойдется
 - gend (masc) должен совпадать
 - выбрать просто первый cdicts[0] - нельзя
 - то есть в probe всегда д.б. все gends
 -

* гипотеза - в качествах и эпитетах могут быть разные парадигмы, независимо от типа склонения


* = простой TAIL
 - отказ: в глаголах при опредлении стема префикс необходим
 - nest-словари делать без префиксов и компаундов. Сохранить только для справки
 - после анализа Антраксом можно создать более точный словарь

* = prefix
 - [ ] выцарапить pfc - префиксы из LSJ - это полные формы. И определять prefix в Guess, и в WKT - по ним
 - [ ] переделать - нужно иметь rdict и полную форму с гласной, кроме краткого pref
 - [ ] WKT с этим списком
 - [ ]

* TODO NOW
 - [ ] pos - на основе tail - везде
 - [ ] nests by LSJ
 - [ ] DVR
 - [ ] indecls
 - [ ]

* = compounds - connector =
 - не могу определить коннектор точно в общем случае. То-ли гласная в приставке, то-ли в стеме
 - придется объеденить. Просто con - коннектор
 - и relatives выбирать по последней гласной в коннекторе
 -

* = compounds = αὐτ-οψία - αὐτοψία
 - здесь sc - οψία, стем οψ
 - все-таки, что в стеме sc - stem / astem без придыхания?
 - пока: com + stem


* = алгоритм nests
 - nests - только морфология, wkt, или cstype для каждой части речи.
 - rdict-pos уникальны
 - wkt + addendum at corrigendum
 - добавляю bbh, lsj, bll, etc
 - русские dvr, bbh.ru
 - при добавлении существующий nest не обновляется
 - ===
 - затем по nests создаются dict.db, с переводами и indecls
 -
 - == нужен общий список indecls?
 -

* TODO == некоторые слова-частицы нужно добавить, хотя их нет в WKT. Куда их добавить?
 - κάρτα =  κάρτα γε - да, конечно
 - κομιδῇ - точно так; конечно
 - παντάπασί - совершенно так; точно так
 - οὔποτε - нет
 -
 -
 -
 -
 - ἐῶ

* BUGS
 - adjective - ῥητορικός
 - οἶδεν - знал



* TODO
 - WKT - тесты name & verb ок
 - добавить BBH по гнездам
 - DVR - cdicts / uniq / nests / dvr

* = аккуратные стемы =
 - но, ясно, что нужно аккуратно вычислять stems - ἅρμα - ἅρματος - astem - ἁρμ + ἁρματ, так-ли
 -

* == как считать stem в компаундах? ==
 - если есть compound, то во freq учитывать только sc
 - пересчитать Nests
 - в компаундах появляется новая сущность - sc - astem без придыхания
 - freq - == по стрипам! ==

* ================= финиш близок ================ 27 мая 2024
 - собрал nests
 - попробовал создать wkt.db - ок
 - можно скоро переходить к anthrax и тестам
 -


* suffix - adverb
 - похоже, нужно отдельные

* = name.dialects = δοῦλος
 - δοῦλος - два диалекта. Но nom-gen один - ος-ου
 - сколько д.б. cstypes ? в makeCdictsWKT.js ?
 - кажется, в wktMake будет один cstype, ος-ου, и там две строки в keys
 - честно вычисляю marpha - т.е. новый morphs для каждого диалекта. А в Nests они сложатся в массив




* TODO = CSTYPE-S =
  - нужно создавать массив cstypes
  - непонятно в глаголах w+, впрочем, тот же массив cstypes
  - непонятно при сравнении BLL / WKT - если несовпадения?
  - брать wkt?; брать, где больше? ==> объединять
  - BLL - doubled - переписать, и потом все переписать
  - итого, в BLL _id: docs - если noun / adj
  - irreg и indecl - отсеиваются в отдельные массивы
  -


* = IRREGS =
 - навести порядок после Nests - общий список irregs
 - скрипты irregs для stem-словарей
 - и общий для основных словарей - wkt, bhh - просто вызвать конкретные утилиты
 -


* TODO = errors in Baiily
 - ἀλ·έλαιον, ου - почуму-то определяется как pref 'ἀ'
 - это одно слово, ἀλέλαιον



* TODO = SUFF
 - κλεινός - freq 2, потому что 2 диалекта. 2 больше 1, и суффикс не определяется
 - = диалекты =
 - при подсчете гнезд не важны. А дают увеличение freq.
 - поэтому в makeCdictsXXX - отдавать dicts[0]
 - βακχεία - type freq 2, suff freq 2, и суффикс не проходит. М.б. при равенстве брать суффикс?


* TODO =
 - bll, wkt - почти готово, записать cdicts
 - создать nest, посчитать astem, type, cstype - nest.db
 - wkt-stem.db
 -

* = Bailly снова == должно быть
 - ἁ·γάλαξ, ακτος -
   = pos : name
   = pref : ἁ
   = gends : [masc, fem]
   = typestr : ξ, ακτος
   = astems : { astem: γαλακτ, type: ξ}
 - вот про type не уверен, но type и не нужен, только astem
 - == но == стем - без префикса, но с lead-гласной, если она есть
 - astem м.б. равно stem, если нет aug, но всегда == без pref+con ==
 - потому что будет группировка по стемам
 - (lead-vow - leadvow? svow - startvow? avow - augvow? - итого, avow)
 - при подготовке stem-словарей avow не мутирует, как в компаундах? мутирует
 - а, кстати, пример на a-привативное + слово с гласной avow - пример - полно
 -

* = nests = PREFS = как определить приставку
 - два признака. lead - в списке приставок
 - продолжение есть в списке FCs, без prefs
 - то есть полное слово - astem, если приставки нет, либо fc без pref
 - этот список составить по Bailly
 - но чтобы его составить, нужно иметь astems / или уже astem ? ок, будет astem
 - и определять во всех словарях, включая wkt - это сэкономит вычисления в anthrax
 - ох, ох
 - и метод определения префикса, isPrefixByStemList - он должен дать 100% на Bailly и LSJ
 -

* TODO сливать Bailly entries BUG
 - "head": "ἄ·θριξ",
 - "str": "<i>gén.</i>",
 - в сл. entry
 -   "head": "ἄτριχος",
   "str": "( ὁ, ἡ )  ....


* = WTF = непонятка - ἀντίον
 - ἀντίον м.б. indecl, preposition, adverb и noun и adjective ἀντίος
 - если в anthrax я ищу indecl и конец, то не найду name
 - при обработке nests ἀντίον есть в indecl-total. Но отбросить, получается, нельзя. Как быть?
 - indecl-total - это wkt. == Не применять в wkt? ==
 - == посчитать regs-wkt, вычесть? ==
 -

* TODO
 - [ ] собрать что есть - bailly, wkt, bbh
 - [ ] суффиксы везде проверить
 - [ ] общий /Nests/cdicts
 - [ ] вычисление nests - nests.db
 - [ ] первый stem-рь с nests - wkt
 - [ ] тесты wkt
 - [ ]

* = irregulars =
 - создать список
 - в каждом прописать rel-astem, ναῦς - rel: ναυμαχία
 - вручную?
 - но в больших словарях - непонятно, слова типа ναῦς пропущу

* = nests - zero-stems
 - заново wkt, patterns - три позиции, nom, gen, zero - νύξ, νυκτός
 - νύξ - rdict = nom, astems: [ zero: true, stem: νυκτ, type: ός]
 - νύξ - irreg, кладу в indecl - получаю и стоп
 - добавить zero также в adjs

* TODO Nests
 - везде - все astems
 - везде - vars
 - убрать trns
 - wkt - вычислять type-str
 -

* = WKT =
 - [ ] dictutils: прочитать, вычислить simple-astem, suf-astem, положить в Nest -
 - [ ] общий для всех словарей astem
 - [ ] /WKT:
 - [ ] вычислить nest-astem, vars-cstype, fls,
 - [ ] создать wkt-stem.db, fls.db
 - [ ]

* = nests = prefferable dicts = - по степени доверия
 - bailly, wkt, lsj, bbh, dvr,
 - если есть rwf из предыдущего, текущий не обрабатывает слово

* = последовательность создания словарей
 - makeCdictsBailly
 - make ...
 - makeNests
 - все stem-dbs заново
 -

* = STRONG = проблема
 - если слово есть в Bailly, я его пропущу. И не получу Strong.number. И не получу ссылку на этот номер 5311 = ὕψος, ους, τό
 - https://www.bibletools.org/index.cfm/fuseaction/Lexicon.show/ID/G5311/
 - https://biblehub.com/greek/5311.htm
 - === можно добавлять при создании stem.db, Читаю BBH, ищу в Nests, из bbh беру Стронг-номер

* TODO
 - [ ] nests - везде type, cstype, stem, astem, pref/aug
 - [ ]

* = UPDATE = - пока сложно:
 - bailly - слово в отдельный файл, rwf.file /Nests
 - astems по первоначальному type посчитаны
 - возникают остатки bads/errors
 - считаю astems-freq, создаю /nests.db
 - == stems.db
 - == обновление ==
   - добавляю новые слово-файлы из lsj, etc
   - обновляю freqs/nests.db
 - == stems.db
 - создаю рабочие словари stem.db: wkt, dvr, lsj, etc - стемы беру из nests.db
 - == rsync ==
 - копирую stem.dbs на сервер
 - == пример ==
   - например, добавил grams, или обновил rwf.files
   - нужно снова прогнать все словари, на случай, если новые слова попадали в bads/errors == иногда ==
   - обычно только этот gram.db
   - == исправил одно слово в xxx.files, из yyy словаря ==
   - можно обновить одну запись в nests
   - и весь yyy.stem.db
   -
 - == пока что, при обновлении одного слова, придется пересоздать всю цепочку ==
 - freqs, nests.db, stem.dbs, rsync
 -
 -

* = update должно быть ==
 - кладу новый rwf.file,
 - система отслеживает, обновляет - только эту запись - nests.db и все stem.dbs
 - нет, не получится только эту запись. Потому что freqs
 - и обновляет сервер
 -

* = SCHEME =
 - read text, make Entry
 - entry: head, str, rdict, dict
 - сделать список indecls по всем словарям
 - regs - убрать indecls
 - regs - pos, simple type, stype, => simple astem - предварительно
 - astem, aug, pref
 - =============> больше словарей, lsj === или использовать вычисленные nests в других словарях сразу?
 - == запись здесь ==
 - nest - группировка - stem, type, cstype
 - astem м.б. равно stem, если нет aug, но всегда без pref+con

* = вопрос: слитные глаголы помещать в nests? типа -ῶ
 - они дадут лишний стем при подсчете nest-freq

* = замечания к nests =
 - compound не точен. очевидные компаунды пропущены. Поэтому compound - только ориентир
 -

   Πλὴν ἰδοὺ ἡ χεὶρ τοῦ παραδιδόντος με
μετ' ἐμοῦ ἐπἰ τῆς τραπέζης,
ὅτι ὁ υἱὸς μὲν τοῦ ἀνθρώπου κατὰ τὸ
ὡρισμένον πορεύεται, πλὴν οὐαὶ
τῷ ἀνθρώπῷ ἐκείνῷ δι' οὗ παραδίδοται
